/*
	Go Language Raspberry Pi Interface
	(c) Copyright David Thorpe 2016-2017
	All Rights Reserved

	Documentation http://djthorpe.github.io/gopi/
	For Licensing and Usage information, please see LICENSE.md
*/

package linux /* import "github.com/djthorpe/gopi/device/linux" */

import (
	"os"
	"syscall"
)

////////////////////////////////////////////////////////////////////////////////
// TYPES

type InputPollMode int

////////////////////////////////////////////////////////////////////////////////
// CONSTANTS

const (
	INPUT_POLL_READFLAGS = syscall.EPOLLIN | syscall.EPOLLRDHUP
	INPUT_POLL_WRITEFLAGS = syscall.EPOLLOUT
)

const (
	INPUT_POLL_MODE_READ InputPollMode = iota
	INPUT_POLL_MODE_WRITE
)

////////////////////////////////////////////////////////////////////////////////
// TYPES

type evPoll struct {
	// Poll file handle
	handle int

	// Events we're waiting for
	events map[int]uint32

	// An event buffer for EpollWait
	waitEventBuf [10]syscall.EpollEvent
	waitEvents   []syscall.EpollEvent

	// An event buffer for EpollCtl
	ctlEvent syscall.EpollEvent
}

////////////////////////////////////////////////////////////////////////////////
// OPEN AND CLOSE

func NewPoll() (*evPoll,error) {
	var err error

	this := new(evPolls)
	if this.handle, err = syscall.EpollCreate1(syscall.EPOLL_CLOEXEC); err != nil {
		if err != syscall.ENOSYS {
			return nil, os.NewSyscallError("epoll_create1", err)
		}
		if this.handle, err = syscall.EpollCreate(16); err != nil {
			return nil, os.NewSyscallError("epoll_create", err)
		}
		syscall.CloseOnExec(this.handle)
	}
	this.events = make(map[int]uint32)

	// success
	return this, nil
}

func (this *evPoll) Close() error {
	return os.NewSyscallError("close", syscall.Close(this.handle))
}

func (this *evPoll) Add(fd int, mode InputPollMode, repeat bool) error {
	var already bool

	this.ctlEvent.Fd = int32(fd)
	this.ctlEvent.Events, already = this.events[fd]
	if repeat == false {
		this.ctlEvent.Events |= syscall.EPOLLONESHOT
	}
	if mode == 'r' {
		p.ctlEvent.Events |= INPUT_POLL_READFLAGS
	} else {
		p.ctlEvent.Events |= INPUT_POLL_WRITEFLAGS
	}

	var op int
	if already {
		op = syscall.EPOLL_CTL_MOD
	} else {
		op = syscall.EPOLL_CTL_ADD
	}
	if err := syscall.EpollCtl(this.handle, op, fd, &this.ctlEvent); err != nil {
		return os.NewSyscallError("epoll_ctl", err)
	}
	this.events[fd] = p.ctlEvent.Events

	// return success
	return nil
}

func (p *pollster) Remove(fd int, mode InputPollMode) {
	if mode == 'r' {
		this.stopWaiting(fd, INPUT_POLL_READFLAGS)
	} else {
		this.stopWaiting(fd, INPUT_POLL_WRITEFLAGS)
	}

	// Discard any queued up events.
	i := 0
	for i < len(this.waitEvents) {
		if fd == int(this.waitEvents[i].Fd) {
			copy(this.waitEvents[i:], this.waitEvents[i+1:])
			this.waitEvents = this.waitEvents[:len(this.waitEvents)-1]
		} else {
			i++
		}
	}
}


func (p *pollster) StopWaiting(fd int, bits uint) {
	// pollServer is locked.

	events, already := p.events[fd]
	if !already {
		// The fd returned by the kernel may have been
		// cancelled already; return silently.
		return
	}

	// If syscall.EPOLLONESHOT is not set, the wait
	// is a repeating wait, so don't change it.
	if events&syscall.EPOLLONESHOT == 0 {
		return
	}

	// Disable the given bits.
	// If we're still waiting for other events, modify the fd
	// event in the kernel.  Otherwise, delete it.
	events &= ^uint32(bits)
	if int32(events)&^syscall.EPOLLONESHOT != 0 {
		p.ctlEvent.Fd = int32(fd)
		p.ctlEvent.Events = events
		if err := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_MOD, fd, &p.ctlEvent); err != nil {
			print("Epoll modify fd=", fd, ": ", err.Error(), "\n")
		}
		p.events[fd] = events
	} else {
		if err := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_DEL, fd, nil); err != nil {
			print("Epoll delete fd=", fd, ": ", err.Error(), "\n")
		}
		delete(p.events, fd)
	}
}

func (p *pollster) WaitFD(s *pollServer, nsec int64) (fd int, mode int, err error) {
	for len(p.waitEvents) == 0 {
		var msec int = -1
		if nsec > 0 {
			msec = int((nsec + 1e6 - 1) / 1e6)
		}

		s.Unlock()
		n, err := syscall.EpollWait(p.epfd, p.waitEventBuf[0:], msec)
		s.Lock()

		if err != nil {
			if err == syscall.EAGAIN || err == syscall.EINTR {
				continue
			}
			return -1, 0, os.NewSyscallError("epoll_wait", err)
		}
		if n == 0 {
			return -1, 0, nil
		}
		p.waitEvents = p.waitEventBuf[0:n]
	}

	ev := &p.waitEvents[0]
	p.waitEvents = p.waitEvents[1:]

	fd = int(ev.Fd)

	if ev.Events&writeFlags != 0 {
		p.StopWaiting(fd, writeFlags)
		return fd, 'w', nil
	}
	if ev.Events&readFlags != 0 {
		p.StopWaiting(fd, readFlags)
		return fd, 'r', nil
	}

	// Other events are error conditions - wake whoever is waiting.
	events, _ := p.events[fd]
	if events&writeFlags != 0 {
		p.StopWaiting(fd, writeFlags)
		return fd, 'w', nil
	}
	p.StopWaiting(fd, readFlags)
	return fd, 'r', nil
}
