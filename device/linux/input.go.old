/*
	Go Language Raspberry Pi Interface
	(c) Copyright David Thorpe 2016
	All Rights Reserved

	For Licensing and Usage information, please see LICENSE.md
*/

package linux /* import "github.com/djthorpe/gopi/device/linux" */

import (
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strings"
	"syscall"
	"unsafe"
	"encoding/binary"
)

import (
	gopi "github.com/djthorpe/gopi"
	hw "github.com/djthorpe/gopi/hw"
	util "github.com/djthorpe/gopi/util"
)

////////////////////////////////////////////////////////////////////////////////
// CGO INTERFACE

/*
 #include <linux/input.h>
 static int _EVIOCGNAME(int len)        { return EVIOCGNAME(len); }
 static int _EVIOCGPHYS(int len)        { return EVIOCGPHYS(len); }
 static int _EVIOCGUNIQ(int len)        { return EVIOCGUNIQ(len); }
 static int _EVIOCGPROP(int len)        { return EVIOCGPROP(len); }
 static int _EVIOCGKEY(int len)         { return EVIOCGKEY(len); }
 static int _EVIOCGLED(int len)         { return EVIOCGLED(len); }
 static int _EVIOCGSND(int len)         { return EVIOCGSND(len); }
 static int _EVIOCGSW(int len)          { return EVIOCGSW(len); }
 static int _EVIOCGBIT(int ev, int len) { return EVIOCGBIT(ev, len); }
 static int _EVIOCGABS(int abs)         { return EVIOCGABS(abs); }
 static int _EVIOCSABS(int abs)         { return EVIOCSABS(abs); }
*/
import "C"

////////////////////////////////////////////////////////////////////////////////
// TYPES

// Empty input configuration
type Input struct{}

// Driver of multiple input devices
type InputDriver struct {
	log     *util.LoggerDevice // logger
	devices []hw.InputDevice   // input devices
}

type evType uint16

type evEvent struct {
	Second      uint32
	Microsecond uint32
	Type        evType
	Code        uint16
	Value       uint32
}
////////////////////////////////////////////////////////////////////////////////
// CONSTANTS

// Internal constants
const (
	INPUT_PATH_DEVICES   = "/sys/class/input/event*"
	INPUT_MAX_POLL_EVENTS = 32
	MAX_EVENT_SIZE_BYTES = 1024
	MAX_IOCTL_SIZE_BYTES = 256
)

// Event types
// See https://www.kernel.org/doc/Documentation/input/event-codes.txt
const (
	EV_SYN       evType = 0x0000 // Used as markers to separate events
	EV_KEY       evType = 0x0001 // Used to describe state changes of keyboards, buttons
	EV_REL       evType = 0x0002 // Used to describe relative axis value changes
	EV_ABS       evType = 0x0003 // Used to describe absolute axis value changes
	EV_MSC       evType = 0x0004 // Miscellaneous uses that didn't fit anywhere else
	EV_SW        evType = 0x0005 // Used to describe binary state input switches
	EV_LED       evType = 0x0011 // Used to turn LEDs on devices on and off
	EV_SND       evType = 0x0012 // Sound output, such as buzzers
	EV_REP       evType = 0x0014 // Enables autorepeat of keys in the input core
	EV_FF        evType = 0x0015 // Sends force-feedback effects to a device
	EV_PWR       evType = 0x0016 // Power management events
	EV_FF_STATUS evType = 0x0017 // Device reporting of force-feedback effects back to the host
	EV_MAX       evType = 0x001F
)

var (
	EVIOCGNAME = uintptr(C._EVIOCGNAME(MAX_IOCTL_SIZE_BYTES)) // get device name
	EVIOCGPHYS = uintptr(C._EVIOCGPHYS(MAX_IOCTL_SIZE_BYTES)) // get physical location
	EVIOCGUNIQ = uintptr(C._EVIOCGUNIQ(MAX_IOCTL_SIZE_BYTES)) // get unique identifier
	EVIOCGPROP = uintptr(C._EVIOCGPROP(MAX_IOCTL_SIZE_BYTES)) // get device properties
	EVIOCGID   = uintptr(C.EVIOCGID)                          // get device ID
)

////////////////////////////////////////////////////////////////////////////////
// InputDriver OPEN AND CLOSE

// Create new Input object, returns error if not possible
func (config Input) Open(log *util.LoggerDevice) (gopi.Driver, error) {
	log.Debug("<linux.Input>Open")

	// create new GPIO driver
	this := new(InputDriver)

	// Set logging & device
	this.log = log

	// Find devices
	this.devices = make([]hw.InputDevice, 0)
	if err := evFind(func(device *InputDevice) {
		this.devices = append(this.devices, device)
	}); err != nil {
		return nil, err
	}

	// Get capabilities for devices
	for _, device := range this.devices {
		err := device.(*InputDevice).Open()
		defer device.(*InputDevice).Close()
		if err == nil {
			err = device.(*InputDevice).evSetCapabilities()
		}
		if err != nil {
			log.Warn("Device %v: %v",device.GetName(),err)
		}
	}

	this.log.Debug2("<linux.Input>Open {devices=%v}",this.devices)

	// success
	return this, nil
}

// Close Input driver
func (this *InputDriver) Close() error {
	this.log.Debug("<linux.Input>Close")

	for _, device := range this.devices {
		if err := device.Close(); err != nil {
			return err
		}
	}

	return nil
}

func (t evType) String() string {
	switch(t) {
	case EV_SYN:
		return "EV_SYN"
	case EV_KEY:
		return "EV_KEY"
	case EV_REL:
		return "EV_REL"
	case EV_ABS:
		return "EV_ABS"
	case EV_MSC:
		return "EV_MSC"
	case EV_SW:
		return "EV_SW"
	case EV_LED:
		return "EV_LED"
	case EV_SND:
		return "EV_SND"
	case EV_REP:
		return "EV_REP"
	case EV_FF:
		return "EV_FF"
	case EV_PWR:
		return "EV_PWR"
	case EV_FF_STATUS:
		return "EV_FF_STATUS"
	default:
		return "[?? Unknown evType value]"
	}
}

////////////////////////////////////////////////////////////////////////////////
// InputDriver Open devices

func (this *InputDriver) OpenDevicesByName(name string,flags hw.InputDeviceType,callback hw.InputEventCallback) ([]hw.InputDevice,error) {
	this.log.Debug("<linux.Input>OpenDevicesByName name=%v flags=%v",name,flags)

	// create slice for devices
	devices := make([]hw.InputDevice,0)

	// if type is none then change it to any
	if flags == hw.INPUT_TYPE_NONE {
		flags = hw.INPUT_TYPE_ANY
	}

	this.log.Debug2("<linux.Input>OpenDevicesByName name=%v flags=%v",name,flags)

	// select the devices to open. If name non-empty then only devices
	// whose name matches are considered
	for _, device := range this.devices {
		if flags & device.GetType() == hw.INPUT_TYPE_NONE {
			continue
		}
		// open device if it's of type *InputDevice or else just append it
		// so that we can support devices which aren't naitive linux devices
		// later
		concrete_device, ok := device.(*InputDevice)
		if ok == true {
			if name != "" && concrete_device.evMatchesName(name) == false {
				continue
			}
			this.log.Debug("Opening %v",concrete_device)
			if err := concrete_device.Open(); err != nil {
				this.log.Warn("Cannot open: %v: %v",device.GetName(),err)
				continue
			}
			this.log.Debug("Opened %v",concrete_device)
		} else {
			// non-concrete device, assume it has already been opened
			if name != "" && name != device.GetName() {
				continue
			}
		}

		this.log.Debug("Opened %v",device)

		// Now spawn waiting for events in the case of concrete devices
		if ok == true {
			this.log.Debug("waiting for events %v",concrete_device)
			go concrete_device.evWaitForEvents(this.log)
		}

		// append device
		devices = append(devices,device)
	}

	this.log.Debug2("<linux.Input>OpenDevicesByName opened %v devices",len(devices))

	return devices, nil
}

////////////////////////////////////////////////////////////////////////////////
// InputDevice open and close

// Open driver
func (this *InputDevice) Open() error {
	if this.handle != nil {
		if err := this.Close(); err != nil {
			return err
		}
	}
	var err error
	if this.handle, err = os.OpenFile(this.Path, os.O_RDWR, 0); err != nil {
		this.handle = nil
		return err
	}

	// Success
	return nil
}

// Close driver
func (this *InputDevice) Close() error {
	var err error

	// Perform the finish/finished cycle
	if this.finish != nil {
		this.finish <- true
		_ = <- this.finished
	}

	if this.poll != 0 {
		syscall.Close(this.poll)
		this.poll = 0
	}

	if this.handle != nil {
		err = this.handle.Close()
	}
	this.handle = nil
	return err
}

// Start polling
func (this *InputDevice) PollOpen() error {
	if this.poll != 0 {
		if err := this.PollClose(); err != nil {
			return err
		}
	}

	// Create polling
	var err error
	if this.poll, err = syscall.EpollCreate1(0); err != nil {
		this.PollClose()
		return err
	}

	// register the poll with the device
	this.event.Events = syscall.EPOLLIN
	this.event.Fd = int32(this.handle.Fd())
	if err = syscall.EpollCtl(this.poll, syscall.EPOLL_CTL_ADD, int(this.event.Fd), &this.event); err != nil {
		this.PollClose()
		return err
	}

	return nil
}

// Stop polling
func (this *InputDevice) PollClose() error {
	if this.poll == 0 {
		return nil
	}

	if err := syscall.EpollCtl(this.poll, syscall.EPOLL_CTL_DEL, int(this.event.Fd), &this.event); err != nil {
		return err
	}
	this.poll = 0
	return nil
}

////////////////////////////////////////////////////////////////////////////////
// InputDevice implementation

func (this *InputDevice) GetName() string {
	return this.Name
}

func (this *InputDevice) GetType() hw.InputDeviceType {
	return this.Type
}

func (this *InputDevice) GetBus() hw.InputDeviceBus {
	return this.Bus
}

////////////////////////////////////////////////////////////////////////////////
// STRINGIFY

// Strinfigy InputDriver object
func (this *InputDriver) String() string {
	return fmt.Sprintf("<linux.Input>{ devices=%v }", this.devices)
}

// Strinfigy InputDevice object
func (this *InputDevice) String() string {
	return fmt.Sprintf("<linux.InputDevice>{ name=\"%s\" path=%s id=%v type=%v bus=%v product=0x%04X vendor=0x%04X version=0x%04X events=%v fd=%v }", this.Name, this.Path, this.Id, this.Type, this.Bus, this.Product, this.Vendor, this.Version, this.Events, this.handle)
}

////////////////////////////////////////////////////////////////////////////////
// PRIVATE METHODS

func (this *InputDevice) evWaitForEvents(log *util.LoggerDevice) {
	log.Debug2("<linux.InputDevice>evWaitForEvents start input=%v",this)

	// Create channels for finish and finished
	this.finish = make(chan bool)
	this.finished = make(chan bool)

	// Open polling
	if err := this.PollOpen(); err != nil {
		log.Error("<linux.InputDevice>evWaitForEvents PollOpen error: %v",err)
	}

	// Start polling for events
	go this.evPollEvents(log)

	finish := false
	for finish == false {
		select {
		case finish = <- this.finish:
			finish = true
		}
	}

	// Close polling
	if err := this.PollClose(); err != nil {
		log.Error("<linux.InputDevice>evWaitForEvents PollClose error: %v",err)
	}

	this.finished <- true

	log.Debug2("<linux.InputDevice>evWaitForEvents end input=%v",this)
}

// Waits for new raw events, and then executes the callback
func (this *InputDevice) evPollEvents(log *util.LoggerDevice) {
	events := make([]syscall.EpollEvent, INPUT_MAX_POLL_EVENTS)
	for {
		n, err := syscall.EpollWait(this.poll, events, -1)
		if err != nil {
			log.Error("<linux.InputDevice>evPollEvents error: %v",err)
			continue
		}
		if n <= 0 {
			continue
		}
		for _, event := range events[:n] {
			if event.Fd != int32(this.handle.Fd()) {
				continue
			}
			var raw_event evEvent
			err := binary.Read(this.handle, binary.LittleEndian, &raw_event)
			if err == io.EOF {
				return
			}
			if err != nil {
				log.Error("<linux.InputDevice>evPollEvents error: %v",err)
				return
			}
			// process the event
			this.evProcessEvent(raw_event)
		}
	}
}

func (this *InputDevice) evProcessEvent(event evEvent) {
	// Calculate timestamp
	ts := time.Duration(time.Duration(event.Second) * time.Second + time.Duration(event.Microsecond) * time.Microsecond)

}

func (this *InputDevice) evSetCapabilities() error {
	// Get the name of the device
	name, err := evGetName(this.handle)
	if err != nil {
		return err
	}
	this.Name = name

	// Get the physical Id for the device
	id, err := evGetPhys(this.handle)
	// Error is ignored
	if err == nil {
		this.Id = id
	}

	// Get device information
	bus, vendor, product, version, err := evGetInfo(this.handle)
	if err == nil {
		// Error is ignored
		this.Bus = hw.InputDeviceBus(bus)
		this.Vendor = vendor
		this.Product = product
		this.Version = version
	}

	// Get supported events for the device
	events, err := evGetEvents(this.handle)
	if err != nil {
		return err
	}
	this.Events = events

	// Determine the device type - I hope the joystick has EV_MSC
	// events, but this is untested.
	switch {
	case evCheckEvents(events,EV_KEY,EV_LED,EV_REP):
		this.Type = hw.INPUT_TYPE_KEYBOARD
	case evCheckEvents(events,EV_KEY,EV_REL):
		this.Type = hw.INPUT_TYPE_MOUSE
	case evCheckEvents(events,EV_KEY,EV_ABS,EV_MSC):
		this.Type = hw.INPUT_TYPE_JOYSTICK
	case evCheckEvents(events,EV_KEY,EV_ABS):
		this.Type = hw.INPUT_TYPE_TOUCHSCREEN
	}

	return nil
}

// Find all input devices
func evFind(callback func(driver *InputDevice)) error {
	files, err := filepath.Glob(INPUT_PATH_DEVICES)
	if err != nil {
		return err
	}
	for _, file := range files {
		buf, err := ioutil.ReadFile(path.Join(file, "device", "name"))
		if err != nil {
			continue
		}
		device := &InputDevice{Name: strings.TrimSpace(string(buf)), Path: path.Join("/", "dev", "input", path.Base(file))}
		callback(device)
	}
	return nil
}

// Match device name against several ways to refer to the device
func (this *InputDevice) evMatchesName(name string) bool {
	if name == "" {
		return false
	}
	if name == this.Name {
		return true
	}
	if name == this.Id {
		return true
	}
	if name == this.Path {
		return true
	}
	if name == filepath.Base(this.Path) {
		return true
	}
	return false
}

// Get name
func evGetName(handle *os.File) (string, error) {
	name := new([MAX_IOCTL_SIZE_BYTES]C.char)
	err := evIoctl(handle.Fd(), uintptr(EVIOCGNAME), unsafe.Pointer(name))
	if err != 0 {
		return "", err
	}
	return C.GoString(&name[0]), nil
}

// Get physical connection string
func evGetPhys(handle *os.File) (string, error) {
	name := new([MAX_IOCTL_SIZE_BYTES]C.char)
	err := evIoctl(handle.Fd(), uintptr(EVIOCGPHYS), unsafe.Pointer(name))
	if err != 0 {
		return "", err
	}
	return C.GoString(&name[0]), nil
}

// Get device information (bus, vendor, product, version)
func evGetInfo(handle *os.File) (uint16,uint16,uint16,uint16,error) {
	info := [4]uint16{ }
	err := evIoctl(handle.Fd(), uintptr(EVIOCGID), unsafe.Pointer(&info))
	if err != 0 {
		return uint16(0),uint16(0),uint16(0),uint16(0),err
	}
	return info[0],info[1],info[2],info[3],nil
}

// Get supported events
func evGetEvents(handle *os.File) ([]evType,error) {
	evbits := new([EV_MAX >> 3]byte)
	err := evIoctl(handle.Fd(),uintptr(C._EVIOCGBIT(C.int(0), C.int(EV_MAX))), unsafe.Pointer(evbits))
	if err != 0 {
		return nil,err
	}
	capabilities := make([]evType,0)
	evtype := evType(0)
	for i := 0; i < len(evbits); i++ {
		evbyte := evbits[i]
		for j := 0; j < 8; j++ {
			if evbyte & 0x01 != 0x00 {
				capabilities = append(capabilities,evtype)
			}
			evbyte = evbyte >> 1
			evtype++
		}
	}
	return capabilities,nil
}

// Check to make sure all events exist in a list of events
func evCheckEvents(capabilities []evType,types ...evType) bool {
	count := 0
	for _, capability := range capabilities {
		for _, typ := range types {
			if typ == capability {
				count = count + 1
			}
		}
	}
	return (count == len(types))
}

// Call ioctl
func evIoctl(fd uintptr, name uintptr, data unsafe.Pointer) syscall.Errno {
	_, _, err := syscall.RawSyscall(syscall.SYS_IOCTL, fd, name, uintptr(data))
	return err
}

